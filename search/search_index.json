{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SELAMAT DATANG! :) \u00b6 halaman tugas Komputasi Numerik Andreana Triwinata Jurusan Teknik Informatika NIM: 180411100127","title":"beranda"},{"location":"#selamat-datang","text":"halaman tugas Komputasi Numerik Andreana Triwinata Jurusan Teknik Informatika NIM: 180411100127","title":"SELAMAT DATANG! :)"},{"location":"EliminasiGaus/","text":"Eliminasi Gaus \u00b6 Eliminasi Gauss adalah prosedur pemecahan sistem persamaan linear dengan mengubahnya menjadi bentuk matriks eselon baris tereduksi dengan Operasi Baris Elementer. Matriks Eselon Baris Tereduksi adalah sebuah bentuk matriks eselon baris yang lebih disederhanakan yang bertujuan agar lebih mudah dalam pencarian pemecahan (solusi) dari suatu sistem persamaan. Cara penyelesaian dengan menggunakan metode eliminasi Gauss dijabarkan dalam tabel berikut: Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int ( input ( \"Tentukan ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen Matrix: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Substitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Hasil Running Tentukan ordo Matrix : 3 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : - 3 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : - 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 Matrix A : [[ 2. 1. - 1. ] [ 0. 0.5 0.5 ] [ 0. 0. - 1. ]] Nilai X 3 = - 1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0 Eliminasi Gaus Jacobi \u00b6 Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakuakn perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0X0, kemudian membentuk suatu serangkaian vector X1X1, X2X2, \u2026 yang konvergen ke X. Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan Ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Hasil Running Masukkan Ordo Matrix : 3 Masukkan elemen : 2 Masukkan elemen : 1 Masukkan elemen : - 1 Masukkan elemen : - 3 Masukkan elemen : - 1 Masukkan elemen : 2 Masukkan elemen : - 2 Masukkan elemen : 1 Masukkan elemen : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 A : array ([[ 2. , 1. , - 1. ], [ - 3. , - 1. , 2. ], [ - 2. , 1. , 2. ]]) b : array ([ 8. , - 11. , - 3. ]) x : array ([ 34.89370728 , 81.70007324 , 4.78002167 ]) Eliminasi Gaus Seidel \u00b6 Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linear (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan persentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Hasil Running Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : - 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , - 3.0 ] [ 3.375 , 3.9375 , - 2.4375 ] [ 3.34375 , 3.9921875 , - 2.4609375 ] [ 3.36328125 , 3.9990234375 , - 2.4544921875 ] [ 3.36337890625 , 3.9998779296875 , - 2.4546240234375 ] [ 3.36362548828125 , 3.999984741210938 , - 2.4545467529296876 ] [ 3.363632873535156 , 3.999998092651367 , - 2.454546469116211 ] [ 3.3636361404418946 , 3.999999761581421 , - 2.4545454961395263 ] [ 3.363636314430237 , 3.999999970197678 , - 2.454545468267441 ] [ 3.3636363596162795 , 3.9999999962747097 , - 2.45454545540843 ] [ 3.363636362920785 , 3.9999999995343387 , - 2.454545454738554 ] [ 3.363636363568223 , 3.999999999941792 , - 2.454545454561069 ] [ 3.3636363636257154 , 3.999999999992724 , - 2.4545454545482586 ] [ 3.3636363636352455 , 3.9999999999990905 , - 2.4545454545457197 ] [ 3.3636363636362026 , 3.9999999999998868 , - 2.4545454545454963 ] [ 3.3636363636363455 , 3.999999999999986 , - 2.454545454545459 ] [ 3.363636363636361 , 3.9999999999999982 , - 2.454545454545455 ] [ 3.3636363636363633 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , 3.0 ] [ 1.875 , 3.9375 , 2.9625 ] [ 1.99375 , 3.9921875 , 2.9990625 ] [ 1.99828125 , 3.9990234375 , 2.9995078125 ] [ 1.99987890625 , 3.9998779296875 , 2.9999759765625003 ] [ 1.99997548828125 , 3.9999847412109375 , 2.999993247070312 ] [ 1.9999978735351562 , 3.9999980926513667 , 2.999999530883789 ] [ 1.9999996404418945 , 3.9999997615814205 , 2.9999999038604734 ] [ 1.9999999644302369 , 3.9999999701976776 , 2.9999999917325595 ] [ 1.9999999946162794 , 3.9999999962747097 , 2.99999999859157 ] [ 1.9999999994207849 , 3.9999999995343387 , 2.9999999998614464 ] [ 1.9999999999182232 , 3.999999999941793 , 2.999999999978931 ] [ 1.9999999999907154 , 3.999999999992724 , 2.9999999999977414 ] [ 1.9999999999987457 , 3.9999999999990905 , 2.9999999999996803 ] [ 1.9999999999998526 , 3.9999999999998863 , 2.9999999999999636 ] [ 1.9999999999999807 , 3.999999999999986 , 2.999999999999995 ] [ 1.9999999999999978 , 3.9999999999999987 , 2.9999999999999996 ] [ 1.9999999999999996 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ]","title":"Tugas3"},{"location":"EliminasiGaus/#eliminasi-gaus","text":"Eliminasi Gauss adalah prosedur pemecahan sistem persamaan linear dengan mengubahnya menjadi bentuk matriks eselon baris tereduksi dengan Operasi Baris Elementer. Matriks Eselon Baris Tereduksi adalah sebuah bentuk matriks eselon baris yang lebih disederhanakan yang bertujuan agar lebih mudah dalam pencarian pemecahan (solusi) dari suatu sistem persamaan. Cara penyelesaian dengan menggunakan metode eliminasi Gauss dijabarkan dalam tabel berikut: Listing Program import numpy as np #Membuat Matrix A = [] B = [] n = int ( input ( \"Tentukan ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen Matrix: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Substitusi x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Hasil Running Tentukan ordo Matrix : 3 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : - 3 Masukkan elemen Matrix : - 1 Masukkan elemen Matrix : 2 Masukkan elemen Matrix : - 2 Masukkan elemen Matrix : 1 Masukkan elemen Matrix : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 Matrix A : [[ 2. 1. - 1. ] [ 0. 0.5 0.5 ] [ 0. 0. - 1. ]] Nilai X 3 = - 1.0 Nilai X 2 = 3.0 Nilai X 1 = 2.0","title":"Eliminasi Gaus"},{"location":"EliminasiGaus/#eliminasi-gaus-jacobi","text":"Metode Jacobi, adalah metode tak langsung atau metode iteratif yang melakuakn perbaharuan nilai x yang diperoleh tiap iterasi (mirip metode substitusi berurutan). Metode ini hampir sama dengan metode Gauss Seidel, namun tidak melibatkan perhitungan implisit. Metode Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini merupakan suatu teknik penyelesaian SPL berukuran n x n, AX = b, secara iteratif. Proses penyelesaian dimulai dengan suatu hampiran awal terhadap penyelesaian, X0X0, kemudian membentuk suatu serangkaian vector X1X1, X2X2, \u2026 yang konvergen ke X. Listing Program from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan Ordo Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan elemen: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Hasil Running Masukkan Ordo Matrix : 3 Masukkan elemen : 2 Masukkan elemen : 1 Masukkan elemen : - 1 Masukkan elemen : - 3 Masukkan elemen : - 1 Masukkan elemen : 2 Masukkan elemen : - 2 Masukkan elemen : 1 Masukkan elemen : 2 Masukkan Hasil : 8 Masukkan Hasil : - 11 Masukkan Hasil : - 3 A : array ([[ 2. , 1. , - 1. ], [ - 3. , - 1. , 2. ], [ - 2. , 1. , 2. ]]) b : array ([ 8. , - 11. , - 3. ]) x : array ([ 34.89370728 , 81.70007324 , 4.78002167 ])","title":"Eliminasi Gaus Jacobi"},{"location":"EliminasiGaus/#eliminasi-gaus-seidel","text":"Metode Gauss-Seidel digunakan untuk menyelesaikan sistem persamaan linear (SPL) berukuran besar dan proporsi koefisien nolnya besar, seperti sistem-sistem yang banyak ditemukan dalam sistem persamaan diferensial. Metode iterasi Gauss-Seidel dikembangkan dari gagasan metode iterasi pada solusi persamaan tak linier. Teknik iterasi jarang digunakan untuk menyelesaikan SPL berukuran kecil karena metode-metode langsung seperti metode eliminasi Gauss lebih efisien daripada metode iteratif. Akan tetapi, untuk SPL berukuran besar dengan persentase elemen nol pada matriks koefisien besar, teknik iterasi lebih efisien daripada metode langsung dalam hal penggunaan memori komputer maupun waktu komputasi. Dengan metode iterasi Gauss-Seidel sesatan pembulatan dapat diperkecil karena dapat meneruskan iterasi sampai solusinya seteliti mungkin sesuai dengan batas sesatan yang diperbolehkan. Listing Program def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Hasil Running Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : - 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , - 3.0 ] [ 3.375 , 3.9375 , - 2.4375 ] [ 3.34375 , 3.9921875 , - 2.4609375 ] [ 3.36328125 , 3.9990234375 , - 2.4544921875 ] [ 3.36337890625 , 3.9998779296875 , - 2.4546240234375 ] [ 3.36362548828125 , 3.999984741210938 , - 2.4545467529296876 ] [ 3.363632873535156 , 3.999998092651367 , - 2.454546469116211 ] [ 3.3636361404418946 , 3.999999761581421 , - 2.4545454961395263 ] [ 3.363636314430237 , 3.999999970197678 , - 2.454545468267441 ] [ 3.3636363596162795 , 3.9999999962747097 , - 2.45454545540843 ] [ 3.363636362920785 , 3.9999999995343387 , - 2.454545454738554 ] [ 3.363636363568223 , 3.999999999941792 , - 2.454545454561069 ] [ 3.3636363636257154 , 3.999999999992724 , - 2.4545454545482586 ] [ 3.3636363636352455 , 3.9999999999990905 , - 2.4545454545457197 ] [ 3.3636363636362026 , 3.9999999999998868 , - 2.4545454545454963 ] [ 3.3636363636363455 , 3.999999999999986 , - 2.454545454545459 ] [ 3.363636363636361 , 3.9999999999999982 , - 2.454545454545455 ] [ 3.3636363636363633 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] [ 3.3636363636363638 , 4.0 , - 2.4545454545454546 ] Masukkan Panjang Matrix : 3 Masukkan a1 , 1 : 4 Masukkan a1 , 2 : - 1 Masukkan a1 , 3 : 1 Masukkan Hasil : 7 Masukkan a2 , 1 : 4 Masukkan a2 , 2 : - 8 Masukkan a2 , 3 : 1 Masukkan Hasil : - 21 Masukkan a3 , 1 : - 2 Masukkan a3 , 2 : 1 Masukkan a3 , 3 : 5 Masukkan Hasil : 15 [ 0 , 0 , 0 ] [ 1.75 , 3.5 , 3.0 ] [ 1.875 , 3.9375 , 2.9625 ] [ 1.99375 , 3.9921875 , 2.9990625 ] [ 1.99828125 , 3.9990234375 , 2.9995078125 ] [ 1.99987890625 , 3.9998779296875 , 2.9999759765625003 ] [ 1.99997548828125 , 3.9999847412109375 , 2.999993247070312 ] [ 1.9999978735351562 , 3.9999980926513667 , 2.999999530883789 ] [ 1.9999996404418945 , 3.9999997615814205 , 2.9999999038604734 ] [ 1.9999999644302369 , 3.9999999701976776 , 2.9999999917325595 ] [ 1.9999999946162794 , 3.9999999962747097 , 2.99999999859157 ] [ 1.9999999994207849 , 3.9999999995343387 , 2.9999999998614464 ] [ 1.9999999999182232 , 3.999999999941793 , 2.999999999978931 ] [ 1.9999999999907154 , 3.999999999992724 , 2.9999999999977414 ] [ 1.9999999999987457 , 3.9999999999990905 , 2.9999999999996803 ] [ 1.9999999999998526 , 3.9999999999998863 , 2.9999999999999636 ] [ 1.9999999999999807 , 3.999999999999986 , 2.999999999999995 ] [ 1.9999999999999978 , 3.9999999999999987 , 2.9999999999999996 ] [ 1.9999999999999996 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ] [ 2.0 , 4.0 , 3.0 ]","title":"Eliminasi Gaus Seidel"},{"location":"McLaurin/","text":"DERET MCLAURIN Merupakan Suatu fungsi f(x) yang memiliki turunan , , , dan seterusnya yang kontinyu dalam interval dengan maka untuk disekitar yaitu , dapat diekspansi kedalam Deret Taylor. Dalam kasus khusus jika a = 0 , maka disebut Deret MacLaurin atau sering disebut Deret Taylor baku. Dan didefinisikan sebagai berikut Definisi : \u200b $$ f(x) = f(0) + f'(0)x + \\frac{f''(0)}{2!}x^2 + \\frac{f'''(0)}{3!}x^3 + ... + \\frac{f n(0)}{n!}x n $$ Atau bisa dinyatakan dengan: Deret MacLaurin sangat bermanfaat dalam metode numerik untuk menghitung atau menghampiri nilai-nilai fungsi yang sudah dihitung secara manual seperti nilai sin x, cos x , eksponensial, dll. Tentu kita tidak akan bisa menghitung nilai-nilai fungsi tersebut tanpa menggunakan bantuan kalkulator atau tabel. Dalam tulisan ini saya akan mencoba untuk mendekati fungsi-fungsi tersebut menggunakan Deret MacLaurin. Tugas \u00b6 Hitunglah e^2x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001. Penyelesaian \u00b6 Fungsi awal exponen : $$ f(x) = e^2x $$ Dapat juga didefinisikan dengan rumus: Tabel perhitungan untuk turunan exponensial : Berikut adalah penyelesaian untuk mencari nilai expansi : $$ f(x) = f(0) + \\frac{f'(0)}{1!}x + \\frac{f''(0)}{2!}x^2 + \\frac{f'''(0)}{3!}x^3 + \\frac{f''''(0)}{4!}x^4 + ... $$ nilai turunan pada tabel dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x) = 1 + \\frac{2}{1!}x + \\frac{4}{2!}x^2 + \\frac{8}{3!}x^3 + \\frac{16}{4!}x^4 + ... $$ kemudian, nilai x diganti dengan 4: $$ f(x) = 1 + \\frac{2}{1!}4 + \\frac{4}{2!}4^2 + \\frac{8}{3!}4^3 + \\frac{16}{4!}4^4 + ... $$ perhitungan diatas akan terus berulang hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001 LISTING PROGRAM import math error = 0.001 def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) print ( 'f ke-' , i , '=' , 'Ea=' , current - old ) if current - old < error : iteration = False else : f_turunan *= 2 i += 1 f ( 4 ) OUTPUT: f ke - 0 = Ea = 1.0 f ke - 1 = Ea = 8.0 f ke - 2 = Ea = 32.0 f ke - 3 = Ea = 85.33333333333333 f ke - 4 = Ea = 170.66666666666669 f ke - 5 = Ea = 273.0666666666666 f ke - 6 = Ea = 364.08888888888896 f ke - 7 = Ea = 416.1015873015872 f ke - 8 = Ea = 416.1015873015872 f ke - 9 = Ea = 369.8680776014112 f ke - 10 = Ea = 295.89446208112895 f ke - 11 = Ea = 215.195972422639 f ke - 12 = Ea = 143.46398161509296 f ke - 13 = Ea = 88.28552714774924 f ke - 14 = Ea = 50.448872655856576 f ke - 15 = Ea = 26.90606541645684 f ke - 16 = Ea = 13.45303270822842 f ke - 17 = Ea = 6.330838921519444 f ke - 18 = Ea = 2.8137061873417224 f ke - 19 = Ea = 1.184718394670199 f ke - 20 = Ea = 0.47388735786807956 f ke - 21 = Ea = 0.18052851728316455 f ke - 22 = Ea = 0.06564673355751438 f ke - 23 = Ea = 0.022833646454728296 f ke - 24 = Ea = 0.0076112154847578495 f ke - 25 = Ea = 0.0024355889549951826 f ke - 26 = Ea = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$'.'$$']]} }) <script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">","title":"Tugas1"},{"location":"McLaurin/#tugas","text":"Hitunglah e^2x untuk nilai x=4, kemudian expensikan hingga selisih yang dihasilkan kurang dari nilai error yang ditentukan yaitu e < 0,001.","title":"Tugas"},{"location":"McLaurin/#penyelesaian","text":"Fungsi awal exponen : $$ f(x) = e^2x $$ Dapat juga didefinisikan dengan rumus: Tabel perhitungan untuk turunan exponensial : Berikut adalah penyelesaian untuk mencari nilai expansi : $$ f(x) = f(0) + \\frac{f'(0)}{1!}x + \\frac{f''(0)}{2!}x^2 + \\frac{f'''(0)}{3!}x^3 + \\frac{f''''(0)}{4!}x^4 + ... $$ nilai turunan pada tabel dimasukkan kedalam rumus sehingga didapatkan seperti ini : $$ f(x) = 1 + \\frac{2}{1!}x + \\frac{4}{2!}x^2 + \\frac{8}{3!}x^3 + \\frac{16}{4!}x^4 + ... $$ kemudian, nilai x diganti dengan 4: $$ f(x) = 1 + \\frac{2}{1!}4 + \\frac{4}{2!}4^2 + \\frac{8}{3!}4^3 + \\frac{16}{4!}4^4 + ... $$ perhitungan diatas akan terus berulang hingga nilai selisih mendekati nilai error yang ditentukan yaitu kurang dari 0,001 LISTING PROGRAM import math error = 0.001 def f ( x ): f_turunan = 1 current = i = 0 iteration = True while iteration : old = current current += ( f_turunan * ( x ** i )) / math . factorial ( i ) print ( 'f ke-' , i , '=' , 'Ea=' , current - old ) if current - old < error : iteration = False else : f_turunan *= 2 i += 1 f ( 4 ) OUTPUT: f ke - 0 = Ea = 1.0 f ke - 1 = Ea = 8.0 f ke - 2 = Ea = 32.0 f ke - 3 = Ea = 85.33333333333333 f ke - 4 = Ea = 170.66666666666669 f ke - 5 = Ea = 273.0666666666666 f ke - 6 = Ea = 364.08888888888896 f ke - 7 = Ea = 416.1015873015872 f ke - 8 = Ea = 416.1015873015872 f ke - 9 = Ea = 369.8680776014112 f ke - 10 = Ea = 295.89446208112895 f ke - 11 = Ea = 215.195972422639 f ke - 12 = Ea = 143.46398161509296 f ke - 13 = Ea = 88.28552714774924 f ke - 14 = Ea = 50.448872655856576 f ke - 15 = Ea = 26.90606541645684 f ke - 16 = Ea = 13.45303270822842 f ke - 17 = Ea = 6.330838921519444 f ke - 18 = Ea = 2.8137061873417224 f ke - 19 = Ea = 1.184718394670199 f ke - 20 = Ea = 0.47388735786807956 f ke - 21 = Ea = 0.18052851728316455 f ke - 22 = Ea = 0.06564673355751438 f ke - 23 = Ea = 0.022833646454728296 f ke - 24 = Ea = 0.0076112154847578495 f ke - 25 = Ea = 0.0024355889549951826 f ke - 26 = Ea = 0.0007494119863622473 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$'.'$$']]} }) <script type=\"text/javascript\" async src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\">","title":"Penyelesaian"},{"location":"MetodeEuler/","text":"METODE EULER Metode Euler bisa diartikan dengan prosedur numerik pertama untuk menyelesaikan persamaan diferensial biasa dengan nilai awal yang diberikan. Metode Euler merupakan metode eksplisit paling dasar untuk integrasi numerik persamaan diferensial biasa dengan merupakan metode Runget-Kutta paling sederhana dibandingkan dengan yang lainnya. Metode euler atau disebut juga metode orde pertama karena persamaannya kita hanya mengambil sampai suku orde pertama saja, yang berarti bahwa kesalahan lokal (kesalahan per langkah) sebanding dengan kuadrat ukuran langkah, dan kesalahan global (kesalahan pada waktu tertentu) sebanding dengan ukuran langkah. Misalnya diberikan Persamaan Diferensial Biasa orde satu. Contoh temukan y(1.01), y(1.02), dan y(1.03) dengan menggunakan metode Euler untuk menyelesaikan Persamaan Diferensia Biasa. Source Code import numpy as np #Parameter untuk Euler y0 = - 4 x0 = float ( input ( \"masukkan nilai x0 :\" )) n = 4 h = 0.01 y = 0 hasil = y0 #Metode Euler for i in range ( 1 , n ): hasil = y0 + h * ( 1 + ( x0 ) ** 2 ) x0 += h y0 = hasil print ( \"Langkah\" + str ( i ) + \": y\" + str ( i ) + \"= \" + str ( hasil )) Hasil Running Langkah1 : y1 = - 3.98 Langkah2 : y2 = - 3.959799 Langkah3 : y3 = - 3.9393949999999998 Process finished with exit code 0","title":"Tugas6"},{"location":"MonteCarloMethods/","text":"Monte Carlo Methods Metode Monte Carlo adalah kelas teknik untuk pengambilan sampel secara acak suatu distribusi probabilitas. Pada Konsep Umumnya: Telah ditemukan dalam konteks pengembangan bom atom pada tahun 1940-an. Bisa diaplikasikan untuk berbagai masalah. Bukan alat statistik. Bisa mengandalkan pengambilan sampel acak berulang. Biasanya memberikan solusi perkiraan. Bisa digunakan dalam kasus di mana analitis atau numerik solusi tidak ada atau terlalu sulit untuk diterapkan. Juga dapat digunakan oleh Lazy ScientistTM bahkan ketika sebuah solusi analitis atau numerik dapat diterapkan. Monte Carlo biasanya juga mengikuti beberapa petujuk yaitu: Tentukan sifat statistik input yang memungkinkan Hasilkan banyak set input yang mungkin berikut properti di atas Lakukan perhitungan deterministik dengan set ini Analisis hasilnya secara statistik Kesalahan pada hasil biasanya berkurang 1 / \u221a N Ada banyak domain masalah di mana menggambarkan atau memperkirakan distribusi probabilitas relatif mudah, tetapi menghitung jumlah yang diinginkan tidak bisa dilakukan. Ini mungkin karena banyak alasan, seperti sifat stokastik domain atau jumlah variabel acak eksponensial. Alih-alih, jumlah yang diinginkan dapat diperkirakan dengan menggunakan pengambilan sampel acak, disebut sebagai metode Monte Carlo. Metode-metode ini awalnya digunakan sekitar waktu ketika komputer pertama diciptakan dan tetap meresap melalui semua bidang sains dan teknik, termasuk kecerdasan buatan dan pembelajaran mesin. Fungsi NumPy normal () dapat digunakan untuk mengambil sampel secara acak dari distribusi Gaussian dengan rata-rata yang ditentukan (mu), standar deviasi (sigma), dan ukuran sampel. Untuk membuat contoh lebih menarik, kami akan mengulangi percobaan ini empat kali dengan sampel berukuran berbeda. Kami berharap bahwa ketika ukuran sampel meningkat, kepadatan probabilitas akan lebih baik mendekati kepadatan sebenarnya dari fungsi target, mengingat hukum jumlah besar. # example of effect of size on monte carlo sample from numpy.random import normal from matplotlib import pyplot # define the distribution mu = 50 sigma = 5 # generate monte carlo samples of differing size sizes = [ 10 , 50 , 100 , 1000 ] for i in range ( len ( sizes )): # generate sample sample = normal ( mu , sigma , sizes [ i ]) # plot histogram of sample pyplot . subplot ( 2 , 2 , i + 1 ) pyplot . hist ( sample , bins = 20 ) pyplot . title ( ' %d samples' % sizes [ i ]) pyplot . xticks ([]) # show the plot pyplot . show () Menjalankan contoh membuat empat sampel berukuran berbeda dan plot histogram untuk masing-masing. Kita dapat melihat bahwa ukuran sampel kecil 10 dan 50 tidak secara efektif menangkap kepadatan fungsi target. Kita dapat melihat bahwa 100 sampel lebih baik, tetapi tidak sampai 1.000 sampel kita melihat dengan jelas bentuk lonceng yang umum dari distribusi probabilitas Gaussian. Ini menyoroti kebutuhan untuk menarik banyak sampel, bahkan untuk variabel acak sederhana, dan manfaat peningkatan akurasi perkiraan dengan jumlah sampel yang diambil Untuk penerapan contoh lain yang menggunakan Metode Monte Carlos. Tulis sebuah program untuk memverifikasi angka itu . Menggunakan metode monte carlo dan 2500 angka acak. from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 def func ( x ): return ( 4 - x ** 2 ) ** 0.5 area = [] for i in range ( N ): xrand = np . zeros ( N ) for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) integral = 0.0 for i in range ( N ): integral += func ( xrand [ i ]) jawab = ( b - a ) / float ( N ) * integral area . append ( jawab ) plt . title ( \"Hasil phi\" ) plt . hist ( area , bins = 30 , ec = 'black' ) plt . xlabel ( \"Area\" ) plt . show () Hasil running.","title":"Tugas7"},{"location":"NewtonRhapson/","text":"\u200b Metode Newton-Raphson Dengan Python Newton-Raphson merupakan metode yang memanfaatkan turunan dan akar awal dari persamaan untuk mencari akar dari persamaan non linier.Untuk rumus Newton-Raphson sendiri adalah Keterangan : xn = akar ke n xn-1 = akar ke n-1 f(xn-1) = fungsi persamaan dari akar ke n-1 f'(xn-1) = fungsi turunan persamaan dari akar ke n-1 Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 sebagai berikut : Listing Program \u00b6 import math def f ( x ): function = ( x * x * x ) - ( 2 * x ) - 1 return function def derivative ( x ): h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) def iterate ( p , n ): x = p for i in range ( n ): x = newton_raphson ( x ) print ( x ) return ( \"\" ) print ( iterate ( 1 , 10 )) Output sebagai berikut : 2.999994000093219 2.199996832027392 1.780829491896542 1.6363030634057565 1.618304588651506 1.6180340496697716 1.6180339887499486 1.6180339887498947 1.6180339887498947 1.6180339887498947","title":"Tugas2"},{"location":"NewtonRhapson/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 sebagai berikut :","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson"},{"location":"NewtonRhapson/#listing-program","text":"import math def f ( x ): function = ( x * x * x ) - ( 2 * x ) - 1 return function def derivative ( x ): h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) def iterate ( p , n ): x = p for i in range ( n ): x = newton_raphson ( x ) print ( x ) return ( \"\" ) print ( iterate ( 1 , 10 )) Output sebagai berikut : 2.999994000093219 2.199996832027392 1.780829491896542 1.6363030634057565 1.618304588651506 1.6180340496697716 1.6180339887499486 1.6180339887498947 1.6180339887498947 1.6180339887498947","title":"Listing Program"},{"location":"Pemrograman%20Newton%20Rhapson/","text":"\u200b Metode Newton-Raphson Dengan Python Newton-Raphson merupakan metode yang memanfaatkan turunan dan akar awal dari persamaan untuk mencari akar dari persamaan non linier.Untuk rumus Newton-Raphson sendiri adalah Keterangan : xn = akar ke n xn-1 = akar ke n-1 f(xn-1) = fungsi persamaan dari akar ke n-1 f'(xn-1) = fungsi turunan persamaan dari akar ke n-1 Menyusun Algoritma dan Pemrograman Newton Rhapson \u00b6 dari rumus yang kita dapat kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 sebagai berikut : Listing Program \u00b6 import math def f ( x ): function = ( x * x * x ) - ( 2 * x ) - 1 return function def derivative ( x ): h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) def iterate ( p , n ): x = p for i in range ( n ): x = newton_raphson ( x ) print ( x ) return ( \"\" ) print ( iterate ( 1 , 10 )) Output sebagai berikut : 2.999994000093219 2.199996832027392 1.780829491896542 1.6363030634057565 1.618304588651506 1.6180340496697716 1.6180339887499486 1.6180339887498947 1.6180339887498947 1.6180339887498947","title":"Pemrograman Newton Rhapson"},{"location":"Pemrograman%20Newton%20Rhapson/#menyusun-algoritma-dan-pemrograman-newton-rhapson","text":"dari rumus yang kita dapat kita dapat menyusun sebuah algoritma yang nantinya akan dibuat menjadi sebuah program. Algoritma menyusun akar - akar f(x) = 0 sebagai berikut :","title":"Menyusun Algoritma dan Pemrograman Newton Rhapson"},{"location":"Pemrograman%20Newton%20Rhapson/#listing-program","text":"import math def f ( x ): function = ( x * x * x ) - ( 2 * x ) - 1 return function def derivative ( x ): h = 0.000001 derivative = ( f ( x + h ) - f ( x )) / h return derivative def newton_raphson ( x ): return ( x - ( f ( x ) / derivative ( x ))) def iterate ( p , n ): x = p for i in range ( n ): x = newton_raphson ( x ) print ( x ) return ( \"\" ) print ( iterate ( 1 , 10 )) Output sebagai berikut : 2.999994000093219 2.199996832027392 1.780829491896542 1.6363030634057565 1.618304588651506 1.6180340496697716 1.6180339887499486 1.6180339887498947 1.6180339887498947 1.6180339887498947","title":"Listing Program"},{"location":"RecrusiveTrapezoid/","text":"INTEGRASI NUMERIK \u00b6 Metode Integrasi Numerik adalah salah satu cara untuk menghitung aproksimasi luas daerah di bawah fungsi yang dimaksud pada selang yang diberikan. Ada beberapa metode integrasi numerik yang lazim digunakan, diantaranya yaitu: Metode Euler Eksplisit Metode Euler Implisit pada metode integrasi implisit nilai aktual Xk juga digunakan sebagai umpan balik. Umpan balik ini dapat menyebabkan terjadinya lingkaran aljabar. untuk menghindarinya maka bentuk persamaan diubah menjadi seperti ini. METODE TRAPEZOID Aturan Trapezoid adalah suatu metode pendekatan integral numerik dengan polinomade satu. Metode trapezoid ini dapat diturunkan dengan substitusi fungsi Lagrange orde-1 sebagai f(x) yaitu: dengan demikian dapat dirumuskan: Dimana R adalah suku yang mengandung error komputasi O(h3). Sehingga kita mendapatkan rumus integral trapezoid yaitu: Dalam matematika , dan lebih khusus lagi dalam analisis numerik, aturan trapesium (juga dikenal sebagai Trapezoid Rule ) adalah teknik untuk mendekati integral yang pasti. Estimasi berdasarkan 1 Interval \u00b6 Algoritma Integral Trapezoida \u00b6 Definisikan y = f(x) Tentukan batas bawah (a) dan batas atas (b) integrasi Tentukan jumlah pembagi n Hitung h = (b-a)/2 Hitung Listing Program #definisi fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \"fungsi yang digunakan adalah\" ) print ( \"\" ) print ( \" \\t\\t \" , \"f(x) = 1/(1+x)\" ) print ( \"\" ) a = float ( input ( \"masukkan batas bawah integral : \" )) b = float ( input ( \"masukkan batas atas integral : \" )) c = int ( input ( \"masukkan n : \" )) eror = [] print ( \"\" ) print ( \"----------------Hasil Integrasi-----------------\" ) print ( \"iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trap = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 eror . append ( trap ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trap ) print ( eror [ iterasi - 1 ]) print ( eror [ iterasi ]) hasil = ( eror [ iterasi - 1 ] - eror [ iterasi ]) print ( hasil ) print ( \"estimasi error : \" + str ( hasil )) \u200b Running fungsi yang digunakan adalah f ( x ) = 1 / ( 1 + x ) masukkan batas bawah integral : 18 masukkan batas atas integral : 2 masukkan n : 10 ---------------- Hasil Integrasi ----------------- iterasi n Trapezoid 1 1 - 3.087719298245614 2 2 - 2.271132376395534 3 4 - 1.9736614262930052 4 8 - 1.880546148038408 5 16 - 1.854757201003331 6 32 - 1.8480774518918412 7 64 - 1.846390566377457 8 128 - 1.8459677344642065 9 256 - 1.8458619561915175 10 512 - 1.8458355072157113 - 1.8458619561915175 - 1.8458355072157113 - 2.644897580617034e-05 estimasi error : - 2.644897580617034e-05 \u200b \u200b","title":"Tugas4"},{"location":"RecrusiveTrapezoid/#integrasi-numerik","text":"Metode Integrasi Numerik adalah salah satu cara untuk menghitung aproksimasi luas daerah di bawah fungsi yang dimaksud pada selang yang diberikan. Ada beberapa metode integrasi numerik yang lazim digunakan, diantaranya yaitu: Metode Euler Eksplisit Metode Euler Implisit pada metode integrasi implisit nilai aktual Xk juga digunakan sebagai umpan balik. Umpan balik ini dapat menyebabkan terjadinya lingkaran aljabar. untuk menghindarinya maka bentuk persamaan diubah menjadi seperti ini. METODE TRAPEZOID Aturan Trapezoid adalah suatu metode pendekatan integral numerik dengan polinomade satu. Metode trapezoid ini dapat diturunkan dengan substitusi fungsi Lagrange orde-1 sebagai f(x) yaitu: dengan demikian dapat dirumuskan: Dimana R adalah suku yang mengandung error komputasi O(h3). Sehingga kita mendapatkan rumus integral trapezoid yaitu: Dalam matematika , dan lebih khusus lagi dalam analisis numerik, aturan trapesium (juga dikenal sebagai Trapezoid Rule ) adalah teknik untuk mendekati integral yang pasti.","title":"INTEGRASI NUMERIK"},{"location":"RecrusiveTrapezoid/#estimasi-berdasarkan-1-interval","text":"","title":"Estimasi berdasarkan 1 Interval"},{"location":"RecrusiveTrapezoid/#algoritma-integral-trapezoida","text":"Definisikan y = f(x) Tentukan batas bawah (a) dan batas atas (b) integrasi Tentukan jumlah pembagi n Hitung h = (b-a)/2 Hitung Listing Program #definisi fungsi def fungsi ( x ): y = 1 / ( 1 + x ) return y print ( \"fungsi yang digunakan adalah\" ) print ( \"\" ) print ( \" \\t\\t \" , \"f(x) = 1/(1+x)\" ) print ( \"\" ) a = float ( input ( \"masukkan batas bawah integral : \" )) b = float ( input ( \"masukkan batas atas integral : \" )) c = int ( input ( \"masukkan n : \" )) eror = [] print ( \"\" ) print ( \"----------------Hasil Integrasi-----------------\" ) print ( \"iterasi\" , \" \\t \" , \"n\" , \" \\t\\t \" , \"Trapezoid\" ) for iterasi in range ( 0 , c ): n = 2 ** iterasi h = ( b - a ) / n xi = a y = 0 for i in range ( 1 , n ): xi = xi + h y += fungsi ( xi ) trap = (( h ) * ( fungsi ( a ) + ( 2 * y ) + fungsi ( b ))) / 2 eror . append ( trap ) print ( iterasi + 1 , \" \\t\\t \" , n , \" \\t\\t \" , trap ) print ( eror [ iterasi - 1 ]) print ( eror [ iterasi ]) hasil = ( eror [ iterasi - 1 ] - eror [ iterasi ]) print ( hasil ) print ( \"estimasi error : \" + str ( hasil )) \u200b Running fungsi yang digunakan adalah f ( x ) = 1 / ( 1 + x ) masukkan batas bawah integral : 18 masukkan batas atas integral : 2 masukkan n : 10 ---------------- Hasil Integrasi ----------------- iterasi n Trapezoid 1 1 - 3.087719298245614 2 2 - 2.271132376395534 3 4 - 1.9736614262930052 4 8 - 1.880546148038408 5 16 - 1.854757201003331 6 32 - 1.8480774518918412 7 64 - 1.846390566377457 8 128 - 1.8459677344642065 9 256 - 1.8458619561915175 10 512 - 1.8458355072157113 - 1.8458619561915175 - 1.8458355072157113 - 2.644897580617034e-05 estimasi error : - 2.644897580617034e-05 \u200b \u200b","title":"Algoritma Integral Trapezoida"},{"location":"RichardsonExtrapolation/","text":"Richardson Extrapolation \u00b6 Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Richardson Extrapolation merupakan salah satu teknik menggabungkan dua nilai perkiraan yang dihitung diperoleh dengan menggunakan rumus yang sama atau metode dengan dua ukuran langkah yang berbeda, untuk mendapatkan metode orde tinggi yang menyediakan lebih dekat perkiraan jumlah tertentu. Beda terpusat ( central difference ): f'(x) = \\frac{f(x+h)-f(x-h)}{2h} + o(h^2) f'(x) = \\frac{f(x+h)-f(x-h)}{2h} + o(h^2) ditetapkan f(x) f(x) dan x x tertentu: Kita dapat mencoba untuk memperkirakan nilai tepat e e dengan perkiraan a(h) a(h) . Dalam hal ini, e e adalah turunan dari f(1)(x) f(1)(x) dan perkiraannya adalah (h)=(f(x+h)\u2212f(x\u2212h))/(2h) (h)=(f(x+h)\u2212f(x\u2212h))/(2h) . Misalkan sekarang kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e=a(h)+Khn+o(hn) e=a(h)+Khn+o(hn) Apabila menggunakan h/2 h/2 : e=a(h/2)+K(h/2)n+o((h/2)n) = a(h/2)+K/2nhn+o(hn) e=a(h/2)+K(h/2)n+o((h/2)n) = a(h/2)+K/2nhn+o(hn) Mengalikan kedua ekspresi ini dengan 2n2n dan mengurangi hasil persamaan pertama 2ne\u2212e=2na(h/2)\u2212a(h)+K/2nhn\u2212Khn+o(hn) 2ne\u2212e=2na(h/2)\u2212a(h)+K/2nhn\u2212Khn+o(hn) Perhatikan bahwa istilah hnhn dibatalkan dan kita dibiarkan dengan (2n\u22121)e=2na(h/2)\u2212a(h)+o(hn) (2n\u22121)e=2na(h/2)\u2212a(h)+o(hn) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk KnhnKnhn. Dapat kita tulis dengan : K1=\u22121/6f(3)(x)h2,etc. K1=\u22121/6f(3)(x)h2,etc. Listing program \u00b6 from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '====================Richardson Extrapolation====================' ) print ( 'SOAL \\n f(x) = \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 \\n ' 'Mulai dengan h1 = 0.5 dan h2 = 0.25, hitung estimasi dengan f\u2019(0.5) menggunakan Richardson Extrapolation' ) print ( '================================================================' ) print ( 'f = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5' ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( '================================================================' ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) print ( '================================================================' ) Hasil Running C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komputasi Numerik/RichardshonExtrapolation.py\" ==================== Richardson Extrapolation ==================== SOAL f ( x ) = \u2013 0.1 x4 \u2013 0.15 x3 \u2013 0.5 x2 \u2013 0.25 x + 1.2 Mulai dengan h1 = 0.5 dan h2 = 0.25 , hitung estimasi dengan f \u2019 ( 0.5 ) menggunakan Richardson Extrapolation ================================================================ f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 - 0.91250000000000530687 ================================================================ diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050 ================================================================ Process finished with exit code 0","title":"Tugas5"},{"location":"RichardsonExtrapolation/#richardson-extrapolation","text":"Dalam analisis numerik, Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Richardson Extrapolation merupakan salah satu teknik menggabungkan dua nilai perkiraan yang dihitung diperoleh dengan menggunakan rumus yang sama atau metode dengan dua ukuran langkah yang berbeda, untuk mendapatkan metode orde tinggi yang menyediakan lebih dekat perkiraan jumlah tertentu. Beda terpusat ( central difference ): f'(x) = \\frac{f(x+h)-f(x-h)}{2h} + o(h^2) f'(x) = \\frac{f(x+h)-f(x-h)}{2h} + o(h^2) ditetapkan f(x) f(x) dan x x tertentu: Kita dapat mencoba untuk memperkirakan nilai tepat e e dengan perkiraan a(h) a(h) . Dalam hal ini, e e adalah turunan dari f(1)(x) f(1)(x) dan perkiraannya adalah (h)=(f(x+h)\u2212f(x\u2212h))/(2h) (h)=(f(x+h)\u2212f(x\u2212h))/(2h) . Misalkan sekarang kesalahan aproksimasi didefinisikan oleh serangkaian bentuk Taylor : e=a(h)+Khn+o(hn) e=a(h)+Khn+o(hn) Apabila menggunakan h/2 h/2 : e=a(h/2)+K(h/2)n+o((h/2)n) = a(h/2)+K/2nhn+o(hn) e=a(h/2)+K(h/2)n+o((h/2)n) = a(h/2)+K/2nhn+o(hn) Mengalikan kedua ekspresi ini dengan 2n2n dan mengurangi hasil persamaan pertama 2ne\u2212e=2na(h/2)\u2212a(h)+K/2nhn\u2212Khn+o(hn) 2ne\u2212e=2na(h/2)\u2212a(h)+K/2nhn\u2212Khn+o(hn) Perhatikan bahwa istilah hnhn dibatalkan dan kita dibiarkan dengan (2n\u22121)e=2na(h/2)\u2212a(h)+o(hn) (2n\u22121)e=2na(h/2)\u2212a(h)+o(hn) Jika kita melihat seri Taylor lengkap untuk rumus perbedaan-terpusat yang terpusat, kita perhatikan bahwa istilah kesalahannya dalam bentuk KnhnKnhn. Dapat kita tulis dengan : K1=\u22121/6f(3)(x)h2,etc. K1=\u22121/6f(3)(x)h2,etc.","title":"Richardson Extrapolation"},{"location":"RichardsonExtrapolation/#listing-program","text":"from math import * def zeros ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def Richardson_dif ( func , a ): k = 9 L = zeros ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '====================Richardson Extrapolation====================' ) print ( 'SOAL \\n f(x) = \u20130.1x4 \u2013 0.15x3 \u2013 0.5x2 \u2013 0.25x + 1.2 \\n ' 'Mulai dengan h1 = 0.5 dan h2 = 0.25, hitung estimasi dengan f\u2019(0.5) menggunakan Richardson Extrapolation' ) print ( '================================================================' ) print ( 'f = -0.1*x**4 - 0.15*x**3 - 0.5*x**2 - 0.25*x + 1.2 dengan x = 0.5' ) print ( ' %04.20f ' % Richardson_dif ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( '================================================================' ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % Richardson_dif ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) print ( '================================================================' ) Hasil Running C : \\ Users \\ User \\ AppData \\ Local \\ Programs \\ Python \\ Python37 \\ python . exe \"D:/Tugas Kuliah/Semester 4/Komputasi Numerik/RichardshonExtrapolation.py\" ==================== Richardson Extrapolation ==================== SOAL f ( x ) = \u2013 0.1 x4 \u2013 0.15 x3 \u2013 0.5 x2 \u2013 0.25 x + 1.2 Mulai dengan h1 = 0.5 dan h2 = 0.25 , hitung estimasi dengan f \u2019 ( 0.5 ) menggunakan Richardson Extrapolation ================================================================ f = - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 dengan x = 0.5 - 0.91250000000000530687 ================================================================ diff ( 2 ** cos ( pi + sin ( x )) dengan x = pi / 2 adalah = 0.16849558398154249050 ================================================================ Process finished with exit code 0","title":"Listing program"}]}